#!/usr/bin/env ruby

# build_book 
 
# Assumes scenes in section_dir are ordered.
# If TITLE given writes book/<TITLE>, otherwise TITLE is 
# the current working directory (uppercase) appended with an 
# underscore and an ISO 8601 compliant date string in YYYYMMDD format.
# For example, running this in tdw_1429_1 on 15 Jul 2018 gives:
#   TDW_1429_1_20180715 

# TODO:
# Add other bits; dedication, afterward, author bio, etc.
# Add option to have things out of order.
# Add reports for long words, reading grade level.
# Add configfile (IN PROCESS)
#
require 'fileutils'
require 'optparse'
require 'psych'

defaults = {
  :book_dir     => 'book',
  :config_file  => 'book_config.yml',
  :chapter_dir  => 'chapters',
  :extra_dir    => 'extras',
  :pre_extras   => ['title_page', 'dedication', 'glossary'],
  :post_extras  => ['insider_information', 'afterward', 'author_bio', 'epilogue'],
  :section_dir  => 'sections',
}

def make_title(options)
  if options[:title].nil?
    book_name_base = [options[:this_dir].upcase, options[:today]].join('_')
  else
    book_name_base = options[:title]
  end
  book_name_base.gsub!(/ /, '_')
  book_name = book_name_base.gsub(/[\W]/, '')
end

# Is this even required?
def usage
  cmd = File.basename($PROGRAM_NAME) 
  puts "#{cmd} [ -t <title> ] [ -p ] [ -h ]"
  puts "\t -t <title>   # The title"
  puts "\t -p           # Has a prologue"
  puts "\t -h           # Help menu"
end

options             = Hash.new
options[:this_dir]  = Dir.pwd.split('/')[-1]
options[:today]     = Time.now.strftime("%Y%m%d")

option_parser = OptionParser.new do |opts|
  opts.on('-c CONFIG', '--config', 'Configuration file') do |c|
    options[:config_file] = c
  end
  opts.on('-s SECTION_DIR', '--sections', 'Where the sections are') do |s|
    options[:section_dir] = s 
  end
  opts.on('-h', '--help', 'Help menu') do
    usage
    exit
  end
  opts.on('-t TITLE', '--title', 'Title of the book') do |t|
    options[:title] = t
  end
end
option_parser.parse!

if options.has_key?(:config_file) and File.readable?(options[:config_file])
  configs   = Psych.load_file(options[:config_file])
elsif File.readable?(defaults[:config_file])
  configs   = Psych.load_file(defaults[:config_file])
end

defaults.merge!(configs) if configs
defaults.merge!(options)
defaults.transform_keys! { |k| k.to_sym }

book_name   = make_title(defaults)
book_dir    = defaults[:book_dir]
section_dir = defaults[:section_dir]
extra_dir   = defaults[:extra_dir]
pre_extras  = defaults[:pre_extras]
post_extras = defaults[:post_extras]

if File.directory?(book_dir)
  FileUtils.rm_rf(book_dir)
end
Dir.mkdir(book_dir)

if File.directory?(section_dir)
  section_files = Dir.entries(section_dir)
  section_files.sort!
else
  puts("Need sections.")
  exit
end

book_file     = book_dir + '/' + book_name
header_space  = "\n"
scene_space   = "\n\n\n\n\n"
page_break    = "\n__page_break__\n"

pre_extras.each { |f|
  extra_file_name = extra_dir + '/' + f + '.txt'
  if File.file? extra_file_name
    ex  = File.read(extra_file_name)
    ex.strip!
    ex_array = ex.split(" ")
    File.open(book_file, "a+") { |f|
      f.write(page_break)
      f.write(ex)
    }
  end
}
      
chapter_count = 1
section_files.each do |section_file|
  if section_file.end_with?('.txt')
    section = File.read("#{section_dir}/#{section_file}")
    section.strip!
    section_array = section.split(" ")
    chapter_count_padded = "%03d" % [chapter_count]

    ## ?? Why is each chapter opening the book file?
    File.open(book_file, "a+") { |file|
      file.write(page_break)
      file.write("Chapter #{chapter_count_padded}")
      file.write(header_space)
      file.write(section)
    }
    chapter_count += 1
  end
end

post_extras.each { |f|
  extra_file_name = extra_dir + '/' + f + '.txt'
  if File.file? extra_file_name
    ex  = File.read(extra_file_name)
    ex.strip!
    File.open(book_file, "a+") { |f|
      f.write(page_break)
      f.write(ex)
    }
  end
}

