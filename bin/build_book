#!/usr/bin/env ruby
$VERBOSE = true

# build_book 
 
# Assumes scenes in section_dir are ordered.
# If TITLE given writes book/<TITLE>, otherwise TITLE is 
# the current working directory (uppercase) appended with an 
# underscore and an ISO 8601 compliant date string in YYYYMMDD format.
# For example, running this in tdw_1429_1 on 15 Jul 2018 gives:
#   TDW_1429_1_20180715 

# TODO:
# Add other bits; dedication, afterward, author bio, etc.
# Add option to have things out of order.
# Add reports for long words, reading grade level.
# Done: Add configfile.
# Done: Fix the stupid smart quotes and other non-ASCII characters.
#

require 'fileutils'
require 'optparse'
require 'psych'

$LOAD_PATH << File.expand_path('../lib', __dir__)
require 'bookbot'

defaults = {
  :book_dir     => 'book',
  :config_file  => 'book_config.yml',
  :chapter_dir  => 'chapters',
  :extra_dir    => 'extras',
  :pre_extras   => ['title_page', 'dedication', 'glossary'],
  :post_extras  => ['insider_information', 'afterward', 'author_bio', 'epilogue'],
  :section_dir  => 'sections',
  :scrubbed_dir => 'scrubbed',
}

def make_title(defaults)
  if defaults[:title].nil?
    book_name_base = [defaults[:this_dir].upcase, defaults[:today]].join('_')
  else
    book_name_base = defaults[:title]
  end
  book_name_base.gsub!(/ /, '_')
  book_name = book_name_base.gsub(/[\W]/, '')
end

options             = Hash.new
options[:this_dir]  = Dir.pwd.split('/')[-1]
options[:today]     = Time.now.strftime("%Y%m%d")

option_parser = OptionParser.new do |opts|
  opts.on('-b BOOK_DIR', '--book', 'Output directory for the book') do |b|
    options[:book_dir] = b
  end
  opts.on('-c CONFIG', '--config', 'Configuration file') do |c|
    options[:config_file] = c
  end
  opts.on('-s SECTION_DIR', '--sections', 'Where the sections are') do |s|
    options[:section_dir] = s 
  end
  opts.on('-t TITLE', '--title', 'Title of the book') do |t|
    options[:title] = t
  end
end
option_parser.parse!

if options.has_key?(:config_file) and File.readable?(options[:config_file])
  configs   = Psych.load_file(options[:config_file])
elsif File.readable?(defaults[:config_file])
  configs   = Psych.load_file(defaults[:config_file])
else
  configs   = Hash.new
end

[configs, options].each { |h|
  if h.count > 0
    h.transform_keys! { |k| k.to_sym }
    defaults.merge!(h)
  end
}

book_name     = make_title(defaults)
book_dir      = defaults[:book_dir]
section_dir   = defaults[:section_dir]
extra_dir     = defaults[:extra_dir]
scrubbed_dir  = defaults[:scrubbed_dir]
pre_extras    = defaults[:pre_extras]
post_extras   = defaults[:post_extras]

book_file     = book_dir + '/' + book_name
header_space  = "\n\n"
scene_space   = "\n\n\n\n\n"
page_break    = "\n__page_break__\n"

if File.directory?(book_dir)
  FileUtils.rm_rf(book_dir)
end
Dir.mkdir(book_dir)

if File.directory?(section_dir)
  section_files = Dir.entries(section_dir)
  section_files.sort!
else
  puts("Need sections.")
  exit
end

unless File.directory?(scrubbed_dir)
  Dir.mkdir(scrubbed_dir)
end

# Take a file path to write to the book.
# File must end in ".txt"
def clean_section(section)
  data = File.read(section)
  data.strip!
  data
end

pre_extras.each { |f|
  file_name = extra_dir + '/' + f + '.txt'
  if File.file? file_name
    section = BookBot::Section.new(file_name)
    File.open(book_file, "a+") { |f|
      f.write(page_break)
      f.write(section.to_s)
    }
  end
}
      
chapter_count = 1
section_files.each do |section_file|
  if section_file.end_with?('.txt')
    section = BookBot::Section.new("#{section_dir}/#{section_file}")
    chapter_count_padded = "%03d" % [chapter_count]

    ## ?? Why is each chapter opening the book file?
    File.open(book_file, "a+") { |file|
      file.write(page_break)
      file.write("Chapter #{chapter_count_padded}")
      file.write(header_space)
      file.write(section.to_s)
    }
    chapter_count += 1

    ## Write the scrubbed version.
    scrubbed_file = "#{scrubbed_dir}/#{section_file}"
    File.open(scrubbed_file, "w") { |file|
      file.write(section.to_s)
    }
  else
      puts "Files need to end in .txt."
  end
end

post_extras.each { |f|
  file_name = extra_dir + '/' + f + '.txt'
  if File.file? file_name
    section = BookBot::Section.new(file_name)
    File.open(book_file, "a+") { |f|
      f.write(page_break)
      f.write(section.to_s)
    }
  end
}

