#!/usr/bin/env ruby
$VERBOSE = true

# build_book 
 
# Assumes scenes in section_dir are ordered.
# If TITLE given writes book/<TITLE>, otherwise TITLE is 
# the current working directory (uppercase) appended with an 
# underscore and an ISO 8601 compliant date string in YYYYMMDD format.
# For example, running this in tdw_1429_1 on 15 Jul 2018 gives:
#   TDW_1429_1_20180715 

# TODO:
# Add other bits; dedication, afterward, author bio, etc.
# Add option to have things out of order.
# Add reports for long words, reading grade level.
# Done: Add configfile.
# Done: Fix the stupid smart quotes and other non-ASCII characters.
#

require 'fileutils'
require 'optparse'
require 'psych'

$LOAD_PATH << File.expand_path('../lib', __dir__)
require 'bookbot'

defaults = {
  :book_dir     => 'book',
  :config_file  => 'book_config.yml',
  :chapter_dir  => 'chapters',
  :extra_dir    => 'extras',
  :pre_extras   => ['title_page', 'dedication', 'glossary'],
  :post_extras  => ['insider_information', 'afterward', 'author_bio', 'epilogue'],
  :report_dir   => 'reports',
  :report_file  => 'report.txt',
  :section_dir  => 'sections',
  :scrubbed_dir => 'scrubbed',
}

def make_title(defaults)
  if defaults[:title].nil?
    book_name_base = [defaults[:this_dir].upcase, defaults[:today]].join('_')
  else
    book_name_base = defaults[:title]
  end
  book_name_base.gsub!(/ /, '_')
  book_name = book_name_base.gsub(/[\W]/, '')
end

options             = Hash.new
options[:this_dir]  = Dir.pwd.split('/')[-1]
options[:today]     = Time.now.strftime("%Y%m%d")

option_parser = OptionParser.new do |opts|
  opts.on('-b BOOK_DIR', '--book', 'Output directory for the book') do |b|
    options[:book_dir] = b
  end
  opts.on('-c CONFIG', '--config', 'Configuration file') do |c|
    options[:config_file] = c
  end
  opts.on('-s SECTION_DIR', '--sections', 'Where the sections are') do |s|
    options[:section_dir] = s 
  end
  opts.on('-t TITLE', '--title', 'Title of the book') do |t|
    options[:title] = t
  end
end
option_parser.parse!

if options.has_key?(:config_file) and File.readable?(options[:config_file])
  configs   = Psych.load_file(options[:config_file])
elsif File.readable?(defaults[:config_file])
  configs   = Psych.load_file(defaults[:config_file])
else
  configs   = Hash.new
end

[configs, options].each { |h|
  if h.count > 0
    h.transform_keys! { |k| k.to_sym }
    defaults.merge!(h)
  end
}

book_name       = make_title(defaults)
book_dir        = defaults[:book_dir]
book_file       = File.join(book_dir, book_name)
extra_dir       = defaults[:extra_dir]
post_extras     = defaults[:post_extras]
pre_extras      = defaults[:pre_extras]
report_dir      = defaults[:report_dir]
report_file     = File.join(report_dir, defaults[:report_file])
scrubbed_dir    = defaults[:scrubbed_dir]
section_dir     = defaults[:section_dir]

header_space    = "\n\n"
scene_space     = "\n\n\n\n\n"
page_break      = "\n__page_break__\n"

sections        = Hash.new
section_grades  = Hash.new

if File.directory?(book_dir)
  FileUtils.rm_rf(book_dir)
end
Dir.mkdir(book_dir)

if File.directory?(section_dir)
  section_list  = Dir.entries(section_dir)
  section_files = Array.new
  section_list.each { |f| 
    file_name = File.join(section_dir, f)
    section_files << f unless File.directory?(file_name) 
  }
  section_files.sort!
else
  puts("Need sections.")
  exit
end

unless File.directory?(scrubbed_dir)
  Dir.mkdir(scrubbed_dir)
end

unless File.directory?(report_dir)
  Dir.mkdir(report_dir)
end

# Take a file path to write to the book.
# File must end in ".txt"
def clean_section(section)
  data = File.read(section)
  data.strip!
  data
end

pre_extras.each { |f|
  file_name = extra_dir + '/' + f + '.txt'
  if File.file? file_name
    section = BookBot::Section.new(file_name)
    sections[section.file_name_label] = section
  end
}
      
chapter_count = 1
section_files.each do |section_file|
  if section_file.end_with?('.txt')
    section = BookBot::Section.new("#{section_dir}/#{section_file}")
    section.chapter_number = chapter_count
    chapter_count += 1
    sections[section.file_name_label] = section
    
    #grade   = sections[section.file_name_label.to_sym].grade_level.to_s.to_sym
=begin     
    ## Write the scrubbed version.
    scrubbed_file = "#{scrubbed_dir}/#{section_file}"
    File.open(scrubbed_file, "w") { |file|
      file.write(section.to_s)
    }
=end
  else
    puts "File name is #{section_file}"
    puts "Files need to end in .txt."
  end

end

post_extras.each { |f|
  file_name = extra_dir + '/' + f + '.txt'
  if File.file? file_name
    section = BookBot::Section.new(file_name)
    sections[section.file_name_label] = section
  end
}

# Write the book.
## ?? Why is each chapter opening the book file?
File.open(book_file, "a+") { |file|
  sections.keys.each { |section|
    file.write(page_break)
    #chapter_count_padded = "%03d" % [chapter_count]
    file.write("Chapter #{sections[section].chapter_number}") if sections[section].chapter_number
    file.write(header_space)
    file.write(sections[section].to_s)
  }
}

by_grade = Hash.new
File.open(report_file, "w") { |file|
  sections.keys.each { |section|
    grade     = sections[section].grade_level.to_s
    by_grade[grade] = Array.new unless by_grade[grade]
    by_grade[grade] << sections[section].file_name
    file.print "%s \n" % sections[section].file_name
    file.puts "-----------------"
    file.print "\n\t Grade level: %.1f " % sections[section].grade_level
    file.print "\n\t Avg Word Length: %.1f " % sections[section].average_word_length
    file.print "\n\t Contractions: %d " % sections[section].contraction_count
    file.print "\n\t Total words: %d " % sections[section].count_words
    file.puts
    file.puts
  }


  grades_reverse_sorted = by_grade.keys.sort.reverse
  grades_reverse_sorted.each { |grade|
    file.print "%s  : " % grade
    string = by_grade[grade].join(", ")
    file.puts string
  }
}

